<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" 
          content="default-src 'none'; 
                   script-src 'self' 'unsafe-inline'; 
                   style-src 'self' 'unsafe-inline'; 
                   img-src 'self' data:; 
                   base-uri 'none'; 
                   form-action 'none';">
    
    <title>PW Push</title>
    <link href="./style.css" rel="stylesheet" integrity="sha384-5Bi9qa5qG2vW4XtXmHL7s68k1lY7rsuBFSKMs2lYkS3RLZz+qRb7SjXAYjCWfG4c" crossorigin="anonymous" />

</head>
<body>

    <div class="container">
        <div id="header">
            <h1>PW Push</h1>
            <p class="subtitle" id="page-subtitle">Client-Side Encryption (AES-GCM)</p>
        </div>

        <div id="generator-mode">
            <div class="form-group">
                <label for="secret-input">Secret Message</label>
                <textarea id="secret-input" maxlength="100" placeholder="Enter sensitive data here"></textarea>
                <div id="char-counter" class="char-count">0/100</div>
            </div>

            <div class="form-group">
                <label for="encrypt-pin">Encryption PIN / Passphrase</label>
                <input type="password" id="encrypt-pin" placeholder="Enter a strong PIN or Password" minlength="4" autocomplete="new-password">
                <p class="small-note">Note: A longer passphrase is much more secure than a 4-digit PIN.</p>
            </div>

            <button id="btn-generate">Generate Secure Link</button>
            <div id="gen-error" class="error-msg"></div>

            <div id="result-area" class="hidden">
                <div class="link-container">
                    <input type="text" id="share-link" readonly>
                    <button id="btn-copy">Copy</button>
                </div>
            </div>
        </div>

        <div id="decrypt-mode" class="hidden">
            <div class="form-group">
                <label>Status</label>
                <div style="color: var(--text); margin-bottom: 1rem;">ðŸ”’ Encrypted payload detected</div>
            </div>

            <div class="form-group">
                <label for="decrypt-pin">Enter PIN / Passphrase to Unlock</label>
                <input type="password" id="decrypt-pin" placeholder="Enter PIN" autocomplete="new-password">
            </div>

            <button id="btn-decrypt">Unlock Message</button>
            <div id="decrypt-error" class="error-msg"></div>

            <div id="decrypted-result" class="hidden result-box">
                <label>Decrypted Message:</label>
                <div id="secret-display" style="margin-top:0.5rem; font-family: monospace;"></div>
            </div>
        </div>
    </div>

    <script>
        const PBKDF2_ITERATIONS = 600000;
        const SALT_LENGTH = 16;
        const IV_LENGTH = 12;
        const PAYLOAD_VERSION = 1;

        const getEl = (id) => document.getElementById(id);

        function bufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
        }

        function base64ToBuffer(base64) {
            base64 = base64.replace(/-/g, '+').replace(/_/g, '/');
            while (base64.length % 4) { base64 += '='; }
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes.buffer;
        }

        async function deriveKey(password, salt) {
            const enc = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                "raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]
            );
            return crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: PBKDF2_ITERATIONS,
                    hash: "SHA-256"
                },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                false,
                ["encrypt", "decrypt"]
            );
        }

        async function encryptData(secret, password) {
            const enc = new TextEncoder();
            const salt = crypto.getRandomValues(new Uint8Array(SALT_LENGTH));
            const iv = crypto.getRandomValues(new Uint8Array(IV_LENGTH));
            
            const key = await deriveKey(password, salt);
            const encrypted = await crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv },
                key,
                enc.encode(secret)
            );

            const combined = new Uint8Array(1 + salt.byteLength + iv.byteLength + encrypted.byteLength);
            combined[0] = PAYLOAD_VERSION;
            combined.set(salt, 1);
            combined.set(iv, 1 + salt.byteLength);
            combined.set(new Uint8Array(encrypted), 1 + salt.byteLength + iv.byteLength);

            return bufferToBase64(combined.buffer);
        }

        async function decryptData(packedPayload, password) {
            try {
                const combined = new Uint8Array(base64ToBuffer(packedPayload));
                
                if (combined[0] !== PAYLOAD_VERSION) {
                    throw new Error("Unknown payload version");
                }

                const salt = combined.slice(1, 1 + SALT_LENGTH);
                const iv = combined.slice(1 + SALT_LENGTH, 1 + SALT_LENGTH + IV_LENGTH);
                const ciphertext = combined.slice(1 + SALT_LENGTH + IV_LENGTH);

                const key = await deriveKey(password, salt);
                
                const decrypted = await crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: iv },
                    key,
                    ciphertext
                );

                const dec = new TextDecoder();
                return dec.decode(decrypted);
            } catch (e) {
                console.error(e);
                throw new Error("Decryption failed. Wrong PIN or corrupted data.");
            }
        }

        function initApp() {
            if (!window.crypto || !window.crypto.subtle) {
                const err = getEl('gen-error');
                err.innerText = "Web Crypto API not supported. Please use a modern browser.";
                return;
            }

            const hashContent = window.location.hash.substring(1);
            const params = new URLSearchParams(hashContent);
            const payload = params.get('payload');

            if (payload) {
                getEl('generator-mode').classList.add('hidden');
                getEl('decrypt-mode').classList.remove('hidden');
                getEl('page-subtitle').innerText = "Unlock secure message";
            } else {
                getEl('decrypt-mode').classList.add('hidden');
                getEl('generator-mode').classList.remove('hidden');
            }

            const secretInput = getEl('secret-input');
            const counter = getEl('char-counter');
            if (secretInput) {
                secretInput.addEventListener('input', () => {
                    counter.innerText = `${secretInput.value.length}/100`;
                });
            }

            const btnGenerate = getEl('btn-generate');
            if (btnGenerate) {
                btnGenerate.addEventListener('click', generateSecureLink);
            }

            const shareLinkInput = getEl('share-link');
            if (shareLinkInput) {
                shareLinkInput.addEventListener('click', function() {
                    this.select();
                });
            }

            const btnCopy = getEl('btn-copy');
            if (btnCopy) {
                btnCopy.addEventListener('click', copyLink);
            }

            const btnDecrypt = getEl('btn-decrypt');
            if (btnDecrypt) {
                btnDecrypt.addEventListener('click', decryptPayload);
            }

            const linkReset = getEl('link-reset');
            if (linkReset) {
                linkReset.addEventListener('click', (e) => {
                    e.preventDefault();
                    window.location.hash = '';
                    window.location.reload();
                });
            }
        }

        async function generateSecureLink() {
            const secret = getEl('secret-input').value;
            const pin = getEl('encrypt-pin').value;
            const errEl = getEl('gen-error');

            errEl.innerText = "";
            if (!secret || !pin) {
                errEl.innerText = "Please enter both a secret and a PIN.";
                return;
            }

            if(pin.length < 4) {
                errEl.innerText = "PIN must be at least 4 characters long. Ideally it should be longer than 8 characters.";
                return;
            }

            try {
                const payload = await encryptData(secret, pin);
                const baseUrl = window.location.origin + window.location.pathname;
                const fullUrl = `${baseUrl}#payload=${payload}`;

                getEl('share-link').value = fullUrl;
                getEl('result-area').classList.remove('hidden');
            } catch (e) {
                errEl.innerText = "Error generating crypto: " + e.message;
            }
        }

        async function decryptPayload() {
            const hashContent = window.location.hash.substring(1);
            const params = new URLSearchParams(hashContent);
            const payload = params.get('payload');
            const pin = getEl('decrypt-pin').value;
            const errEl = getEl('decrypt-error');
            const resBox = getEl('decrypted-result');
            const display = getEl('secret-display');

            errEl.innerText = "";
            resBox.classList.add('hidden');

            if (!pin) {
                errEl.innerText = "Please enter the PIN.";
                return;
            }

            try {
                const cleartext = await decryptData(payload, pin);
                display.innerText = cleartext;
                resBox.classList.remove('hidden');
            } catch (e) {
                errEl.innerText = "Incorrect PIN or invalid data.";
            }
        }

        function copyLink() {
            const copyText = getEl("share-link");
            copyText.select();
            document.execCommand("copy"); 
            
            const btn = document.querySelector('.link-container button');
            const original = btn.innerText;
            btn.innerText = "Copied!";
            setTimeout(() => btn.innerText = original, 1500);
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initApp);
        } else {
            initApp();
        }

    </script>
</body>
</html>